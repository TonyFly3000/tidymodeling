{
  "hash": "1bbb2b8c167c244a4b01c5947d50d6f4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"recipe\"\n\nauthor: \"Tony Duan\"\n\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: true\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n---\n\n\n# create recipe step_xxx\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_rec <- recipe(legal_status ~ ., data = trees_train) %>%\n  \n # update the role for tree_id, since this is a variable we might like to keep around for convenience as an identifier for rows but is not a predictor or outcome. \n  update_role(tree_id, new_role = \"ID\") %>%\n  \n# step_other() to collapse categorical levels for species, caretaker, and the site info. Before this step, there were 300+ species!\n  step_other(species, caretaker, threshold = 0.01) %>%\n  \n# create dummy for nominal data exclude outcome\n  step_dummy(all_nominal(), -all_outcomes()) %>%\n  \n# The date column with when each tree was planted may be useful for fitting this model, but probably not the exact date, given how slowly trees grow. Let’s create a year feature from the date, and then remove the original date variable.  \n  step_date(date, features = c(\"year\")) %>%step_rm(date) %>%\n  \n# There are many more DPW maintained trees than not, so let’s downsample the data for training.  \n  step_downsample(legal_status)%>%\n\n# will remove all. predictor variables that contain only a single value\n    step_zv(all_numeric(all_predictors())) %>% \n  \n#  normalize all numeric data\n  step_normalize(all_numeric()) %>% \n\n# use KNN to impute all predictors\nstep_impute_knn(all_predictors()) \n```\n:::\n\n\n# check recipe  check_xxx\n\n::: {.cell}\n\n```{.r .cell-code}\n#> [1] \"check_class\"      \"check_cols\"       \"check_missing\"   \n#> [4] \"check_name\"       \"check_new_data\"   \"check_new_values\"\n#> [7] \"check_range\"      \"check_type\"\n```\n:::\n\n\n# roles to select variables\n\nIn most cases, the right approach for users will be use to use the predictor-specific selectors such as all_numeric_predictors() and all_nominal_predictors(). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhas_role(match = \"predictor\")\n\nhas_type(match = \"numeric\")\n\nall_outcomes()\n\nall_predictors()\n\nall_date()\n\nall_date_predictors()\n\nall_datetime()\n\nall_datetime_predictors()\n\nall_double()\n\nall_double_predictors()\n\nall_factor()\n\nall_factor_predictors()\n\nall_integer()\n\nall_integer_predictors()\n\nall_logical()\n\nall_logical_predictors()\n\nall_nominal()\n\nall_nominal_predictors()\n\nall_numeric()\n\nall_numeric_predictors()\n\nall_ordered()\n\nall_ordered_predictors()\n\nall_string()\n\nall_string_predictors()\n\nall_unordered()\n\nall_unordered_predictors()\n\ncurrent_info()\n```\n:::\n\n\n\n# reference:\n\nhttps://recipes.tidymodels.org/reference/has_role.html",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}