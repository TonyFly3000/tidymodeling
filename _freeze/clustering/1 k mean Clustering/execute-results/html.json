{
  "hash": "ef1add8281c7234587ed0ee6971cba8d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"K mean Clustering\"\nsubtitle: \"with Mall Customers Datase\"\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: true\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n---\n\n\n![](images/p3GHQXL.png){width=\"500\"}\n\n# load package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(janitor)\n```\n:::\n\n\n\n# data\n\n## download data\n\nhttps://www.kaggle.com/datasets/shwetabh123/mall-customer\n\n## input data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_train=read.csv('./data/Mall_Customers.csv')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(df_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"CustomerID\"             \"Genre\"                  \"Age\"                   \n[4] \"Annual.Income..k..\"     \"Spending.Score..1.100.\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_train=df_train %>% clean_names()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(df_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"customer_id\"          \"genre\"                \"age\"                 \n[4] \"annual_income_k\"      \"spending_score_1_100\"\n```\n\n\n:::\n:::\n\n\n## data EDA\n\n# model with Annual Income (k$) and Spending Score (1-100)\n\nThe standard k-means algorithm isn't directly applicable to categorical data, for various reasons. The sample space for categorical data is discrete, and doesn't have a natural origin. A Euclidean distance function on such a space isn't really meaningful. As someone put it, \"The fact a snake possesses neither wheels nor legs allows us to say nothing about the relative value of wheels and legs.\"\n\nThere's a variation of k-means known as k-modes,if we need to include categorical data\n\nSo only get Annual Income (k$) and Spending Score (1-100).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_train2=df_train %>% select(annual_income_k,spending_score_1_100)\n```\n:::\n\n\n# Optimal number of k-clusters\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkclusts <- \n  tibble(k = 1:9) %>%\n  mutate(\n    kclust = map(k, ~kmeans(df_train2, .x)),\n    tidied = map(kclust, tidy),\n    glanced = map(kclust, glance),\n    augmented = map(kclust, augment, df_train2)\n  )\n\nkclusts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 5\n      k kclust   tidied           glanced          augmented         \n  <int> <list>   <list>           <list>           <list>            \n1     1 <kmeans> <tibble [1 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n2     2 <kmeans> <tibble [2 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n3     3 <kmeans> <tibble [3 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n4     4 <kmeans> <tibble [4 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n5     5 <kmeans> <tibble [5 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n6     6 <kmeans> <tibble [6 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n7     7 <kmeans> <tibble [7 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n8     8 <kmeans> <tibble [8 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n9     9 <kmeans> <tibble [9 × 5]> <tibble [1 × 4]> <tibble [200 × 3]>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclusters <- \n  kclusts %>%\n  unnest(cols = c(tidied))\n\nassignments <- \n  kclusts %>% \n  unnest(cols = c(augmented))\n\nclusterings <- \n  kclusts %>%\n  unnest(cols = c(glanced))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(clusterings, aes(k, tot.withinss)) +\n  geom_line() +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](1-k-mean-Clustering_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n\n![](images/0k6ALfB.png){width=\"500\"}\n\n# 5 groups\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkclust <- kmeans(df_train2, centers = 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult=augment(kclust, df_train2)\n```\n:::\n\n\n\n\n\n\n# profiling\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_train3=cbind(df_train,result)%>% clean_names()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df_train3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  customer_id  genre age annual_income_k spending_score_1_100 annual_income_k_2\n1           1   Male  19              15                   39                15\n2           2   Male  21              15                   81                15\n3           3 Female  20              16                    6                16\n4           4 Female  23              16                   77                16\n5           5 Female  31              17                   40                17\n6           6 Female  22              17                   76                17\n  spending_score_1_100_2 cluster\n1                     39       3\n2                     81       2\n3                      6       3\n4                     77       2\n5                     40       3\n6                     76       2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=ggplot(df_train3, aes(annual_income_k, spending_score_1_100,color=cluster)) + geom_point()\np\n```\n\n::: {.cell-output-display}\n![](1-k-mean-Clustering_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## 'annual_income_k'\n\n\n::: {.cell}\n\n```{.r .cell-code}\np=ggplot(df_train3, aes(cluster,annual_income_k,fill=cluster)) + geom_boxplot()\np\n```\n\n::: {.cell-output-display}\n![](1-k-mean-Clustering_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## 'spending_score_1_100'\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np=ggplot(df_train3, aes(cluster,spending_score_1_100,fill=cluster)) + geom_boxplot()\np\n```\n\n::: {.cell-output-display}\n![](1-k-mean-Clustering_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n## Age\n\n\n# reference:\n\nhttps://www.kaggle.com/code/sangwookchn/clustering-techniques-using-scikit-learn\n",
    "supporting": [
      "1-k-mean-Clustering_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}